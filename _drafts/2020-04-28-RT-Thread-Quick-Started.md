---
layout: post
title: RT-Thread 快速入门
tags:
    - RT-Thread
    - 嵌入式
    - RTOS
---

四月花了三天时间读完了一本技术书籍，这是我有史以来读得最快且认真读完了的技术书：《编码：隐匿在计算机软硬件背后的语言》。这本书真的是太牛了，从手电筒和摩尔斯码，到灯泡电路、继电器、门，再到加法器、锁存器，再到存储器，然后就造出了计算机，还编写了机器码程序、汇编程序……一气呵成，过渡非常平滑，讲得非常通俗易懂，不愧是「永不褪色的计算机科学经典著作」。

我以前精读的时候都会做些笔记（还没有成为我的常识，但又看起来是重点的内容），但这次不太好做，因为每个细节看起来都是常识，但整体上来看却又让我惊叹，所以只能不时重温了。不过这里可以高度概括一下计算机的运行过程（简化版）：

+ 现在的计算机，存储设备（random-access memory, RAM，内存）和中央处理器（central processing unit, CPU）是分离的，程序指令（代码，二进制机器代码）和数据都存在内存里，指令的执行（本质还是数据的处理）则在 CPU 中进行；
+ 分离了就涉及通讯，CPU 取指（读取指令）、译码（解析指令、读取可能存在的操作数）、写数据，都会通过总线和内存发生数据传送；
+ 有了内存和 CPU，计算机就可以跑起来了，当 CPU 首次上电或复位时，它会从特定的内存地址开始执行代码，所以如果我们写好了程序的机器代码，并保存到内存的这个特定地址，然后给 CPU 发一个复位信号，CPU 就会开始执行我们的程序了，这就是裸机程序；
+ 只有内存和 CPU 的计算机，程序运行时只有内存里的数据在变来变去，显然很无趣，为此我们需要给它加上输入输出设备，比如键盘鼠标、显示器等，同时内存里的数据会在断电时丢失，所以我们需要硬盘来永久保存数据，这些设备都叫外围设备，外围设备配备了与内存类似的接口，CPU 通过与某种外围设备对应的特定地址（即接口）对其进行读写操作，有的 CPU 中，外围设备实际占用了一些通常用来寻址存储器的地址，这种结构称作内存映像 I/O（memory mapping I/O），这样 CPU 就可以和外围设备进行交互（收发指令，本质是数据）了；
+ CPU 在运行程序时，如果用户敲击键盘，CPU 怎么能立即响应呢？这就要靠 CPU 的中断机制了，不仅是键盘，其他外围设备都可以在需要 CPU 做出响应时给 CPU 发中断信号，CPU 收到中断信号后，会暂停当前正在运行的程序，并保存好上下文（各种寄存器的值），然后开始执行中断处理程序的代码，中断处理程序则根据中断类型、参数，执行不同的处理逻辑，比如读取键盘输入等等；
+ 前面说的都是裸机状态，没有操作系统，但其实操作系统也就是一些程序的集合，它们的主要功能有：各种初始化，硬件资源管理，应用程序调度，让用户和程序能够方便地访问计算机的硬件；用户和操作系统的交互主要是启动应用程序的入口，比如非图像界面命令行、图形界面的桌面，程序和操作系统的交互则是各种 API；

_上面这种内存和 CPU 分离的结构，也叫冯诺依曼结构（当然，冯诺依曼结构的直接定义是将程序指令存储器和数据存储器合并在一起），冯诺依曼结构计算机也叫存储程序计算机，意思就是程序是存在内存里的，而不是存在 CPU 里_。

_但这和 RT-Thread 有什么关系_？当然有关系了，了解了计算机运行的基本过程和原理，我们在编程时才不会一知半解。

_确实有点牵强，不过这就是写博客比写书的好处，轻松自在_ :)

## 缘起

第一次看到 RT-Thread 是在一篇介绍智能音箱操作系统的文章中，当时只知道这是一款国人打造的实时操作系统。过了一段时间后，看了看官方文档，对最推荐的入门开发板「正点原子潘多拉」产生了浓厚的兴趣，18 年时我曾买了一个树莓派 3B+，但……

正点原子和 RT-Thread 的开发文档都很多，但正是因为太多了，动辄几百页的 pdf，看着有点吓人，经过几天的摸索，我总算找到了点门道，今天就在这里分享给大家。

## 开发环境

我上大学时曾有一门课程是在 FPGA 板子上做实验，当时大家都说把代码「烧」进去，以致于后来在另一门课程里开发 Android APP 时也有同学说「烧」。不过后来工作之后，没人说「烧」了，无论是 Android 还是 iOS，大家都说「安装」。

现在接触到这种嵌入式的开发板，似乎大家都不说「安装」，也不说「烧」，而是说「下载」，在淘宝客服的耐心解答下，我才搞明白这件事情 :)

开发 Android 或 iOS APP，我们都通过一根 USB 线连接电脑和手机，这样既能给手机充电，也能向手机里安装 APP；这款潘多拉开发板也很类似，通过一根 USB 线连接电脑和开发板的 ST-LINK USB 接口，然后拨开电源开关，就既能给开发板供电，也能向开发板下载程序了。

嵌入式开发常用的 IDE 是 MDK5，相当于 Android Studio 或 Xcode，ST-LINK 则是帮助我们向开发板下载程序的工具，潘多拉开发板集成了 ST-LINK，所以我们不用额外操心。

我最初尝试在 macOS 上的 Windows 虚拟机里安装 MDK5、编译代码、下载，但虚拟机无法安装 ST-LINK 下载器的驱动，后来换了 Windows 真机才成功。ST-LINK 驱动可以从[官网下载](https://www.st.com/en/development-tools/stsw-link009.html)。

## 裸机例程

正点原子提供了丰富的裸机例程，没有操作系统，直接把程序的二进制代码写在内存的特定地址，然后让 CPU 从这里开始执行。从跑马灯到录音和播放，从网盘把代码下载到电脑里后，都可以直接编译、下载，并且确实做到了 0 warning 0 error，着实不易。资料下载链接可以从[潘多拉 IoT 开发板](http://www.openedv.com/docs/boards/iot/zdyz_panduola.html)中找到。

不过这显然不是本文的主题，我也不打算写裸机程序，而是得用上 RT-Thread 这个实时操作系统。

这里还有一个强大的 COM 通信工具，我第一时间没在文档里看到，所以这里先推荐给大家：[XCOM 串口调试助手软件](http://www.openedv.com/forum.php?mod=viewthread&tid=279749)。有了它，我们就可以查看控制台日志，甚至后面跑 RT-Thread 时，就可以看到命令行，并发送命令了。

另外这里再分享两个链接：[STM32 中的程序在 RAM 还是 FLASH 里运行？](https://blog.csdn.net/u012252959/article/details/80800559)，[stm32 中的程序是在 RAM 里还是 flash 里执行？lr2131 的回答](https://bbs.csdn.net/topics/392020439)，单片机（一个芯片就集成了计算机运行所需的各种芯片）运行程序的过程和前面总结的冯诺依曼结构还有点区别：

> x86 构架的 CPU 是基于冯.诺依曼体系的，即数据和程序存储在一起，而且 PC 机的 RAM 资源相当丰富，从几十 M 到几百 M 甚至是几个 G，客观上能够承受大量的程序数据。  
> 单片机的构架大多是哈弗体系的，即程序和数据分开存储，而且单片的片内 RAM 资源是相当有限的，内部的 RAM 过大会带来成本的大幅度提高。

## `IoT_Board`

[`IoT_Board`](https://github.com/RT-Thread/IoT_Board) 则是 RT-Thread 针对潘多拉开发板准备的 RT-Thread 开发、运行环境，以及 32 个例程。实际上从正点原子淘宝店里买的潘多拉开发板，默认就是下载了 `30_iot_board_demo` 的，我们上电开机后就能体验这款开发板的强大功能。说实话，第一次体验时，「接近感应」和「贴片电机」我就玩得非常开心。

其实 RT-Thread 这个操作系统真是非常小巧，Android 系统代码量是千万行级别，而 RT-Thread 核心代码只有 17 个 C 文件，一共六千多行。

而且 RT-Thread 也不同于常规的 Android/iOS 系统，程序不是在系统运行过程中动态安装的，程序和系统，会在同一个项目里，编译为一个整体，然后下载到开发板。

如果之前向开发板下载过裸机程序，再向开发板下载 RT-Thread 程序时，建议先用 ST-LINK Utility 先烧录一下 `30_iot_board_demo/bin/all.bin`，具体步骤可以参考「UM3005-RT-Thread-IoT Board 开发手册.pdf」文档的「33.3 IoT Board 综合例程使用说明」，否则可能程序起不来。另外我也遇见过断电或重新下载程序后，程序起不来的现象，烧录 `all.bin` 后再下载也能解决问题。

## Env 工具

例程跑够了，下一步该我们自己写代码了。

## 耳返 demo
